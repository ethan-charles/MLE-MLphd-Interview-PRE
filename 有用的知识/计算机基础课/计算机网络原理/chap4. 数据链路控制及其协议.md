# 数据链路控制及其协议

### 1. 定义和功能

#### 1.1 定义

要解决的问题：如何**在有差错的线路上，进行无差错传输**。

数据链路：从数据**发送点**到数据**接收点**所经过的传输途径。有虚拟数据通路和实际数据通路。

![img](https://pic1.zhimg.com/80/v2-027db9d25e78d444ea1c7c4a8314eb21_1440w.png)

#### 1.2 为网络层提供服务
为**网络层**提供三种合理的服务

- 无确认无连接服务。适用于：
  - 误码率很低的线路，错误恢复留给高层；
  - 实时业务
  - 大部分局域网

-  有确认无连接服务：适用于不可靠的信道，如无线网。
- 有确认有连接服务

#### 1.3 成帧（Framing）
将比特流分成离散的帧，并计算每个帧的校验和。
成帧方法：

- 字符计数法

  - 在帧头中用一个**域**来表示整个帧的字符个数
  - 缺点：若计数出错，对本帧和后面的帧有影响。

  ![img](https://pic2.zhimg.com/80/v2-5a9b8e21ca49098eab3fc86ccafc11d7_1440w.jpeg)

- 带字符填充的首尾字符定界法

  - 起始字符 DLE STX，结束字符DLE ETX。其中DLE是”转义“字符
  - 缺点：局限于8位字符和ASCII字符传送。

  ![img](https://pic3.zhimg.com/80/v2-7727611e0ab7b18564877d6806cb8e01_1440w.jpeg)

- 带位填充的首尾标记定界法
  - 帧的起始和结束都用一个特殊的位串“01111110”，称为标记
  - “0”比特插入删除技术

![img](https://pica.zhimg.com/80/v2-dcf6a9b80c7e2c164bf3f2d357b71567_1440w.jpeg)

- 物理层编码违例法
  - 只适用于物理层编码有冗余的网络（使用不可能出现的编码来做定界符）

### 2 错误检测和纠正
差错出现的特点：随机，连续突发（burst）
处理差错的两种基本策略
• 使用**纠错**码：发送方在每个数据块中加入足够的**冗余信息**，使得接收方能够判断接收到的数据是否有错，并**能纠正错误**。
• 使用检错码：发送方在每个数据块中加入足够的冗余信息，使得接收方能够判断接收到的数据是否有错，但**不能判断哪里有错**。最简单的例子是奇偶校验，在数据后填加一个奇偶位，”1“的个数为偶数。奇偶校验可以用来检查奇数个错误。

使用纠错码传数据，效率低，适用于不可能重传的场合；大多数情况采用**检错码加重传**。

经典的检错码：循环冗余码（CRC码，多项式编码）。如110001，表示成多项式 $x^5 + x^4 + 1$. 这个生成多项式G(x)由发方、收方事前商定；CRC码基本思想：校验和加在帧尾，使带校验和（checksum）的帧的多项式能被G(x)除尽；收方接收时，用G(x)去除它，**若有余数，则传输出错**。

### 3.基本的数据链路层协议

#### 3.1 无约束单工协议（An Unrestricted Simplex Protocol）
– 工作在理想情况，几个前提：

- 单工传输
- 发送方无休止工作（要发送的信息无限多）
- 接收方无休止工作（**缓冲区无限大**）
- 通信线路（信道）不损坏或丢失信息

– 工作过程
• 发送程序 :取数据，构成帧，发送帧；
• 接收程序：等待，接收帧，送数据给高层

![img](https://pica.zhimg.com/80/v2-a0cf437c96a3776a046f15d81757ca89_1440w.jpeg)

#### 3.2 单工停等协议（A Simplex Stop-and-Wait Protocol）
– 增加约束条件：接收方**不能无休止接收**。（接收方的缓冲区有限）
– 解决办法：接收方每收到一个帧后，给发送方回送一个响应（告诉发送方可以再发了）。
– 工作过程
• 发送程序：取数据，成帧，发送帧，**等待响应帧**；
• 接收程序：等待，接收帧，送数据给高层，**回送响应帧**。

![img](https://pic2.zhimg.com/80/v2-41a28bf0f662dd859b6ca4afa3c9ef30_1440w.jpeg)

#### 3.3 有噪声信道的单工协议（A Simplex Protocol for a Noisy Channel）
– 增加约束条件：信道（线路）**有差错**，信息帧可能损坏或丢失。
– 解决办法：**出错重传**。如果正确到达，则接受方发送相应帧；如果错误/丢失，则等待超时重传。

-问题：

- 响应帧损坏怎么办？如果相应帧损坏，发送方会认为接收方没有收到，然后再发一次。这样接收方就会收到重复帧。解决方法—— 发送帧头中放入序号，只有接收方接收到想要的序号时才会处理收到的帧。通过计时器和序号保证每帧最终交给目的网络层**仅一次**是数据链路层的一个主要功能。
- 为了使帧头精简，序号取多少位 —— 1位

这种发送方在发下一个帧之前等待一个肯定**确认**的协议叫做PAR（Positive Acknowledgement with Retransmission）

![img](https://pic1.zhimg.com/80/v2-b17d5fa475d89a70119b94021a19f0a6_1440w.jpeg)

#### 3.4 滑动窗口协议

- 单工 ——> 全双工
- 捎带（piggybacking）：暂时**延迟待发确认**（指接收方接收到了之后也不马上发回ack，而是等待有下一个待发数据帧的时候附在数据帧前面发送）
  - 优点：充分利用信道带宽，减少帧的数目意味着减少“帧到达”中断；
  - 带来的问题：复杂。

- 工作原理

  - 发送方：

    - **发送的信息帧**都有一个序号，从0到某个最大值，$0 \to 2^n-1$，用n个二进制位表示；
    - 发送端始终保持一个**已发送但尚未确认的帧**的序号表，称为发送窗口。发送窗口的上界表示要发送的下一个帧的序号，下界表示未得到确认的帧的最小编号。发送窗口 = 上界 - 下界，大小可变；
    - 发送端每发送一个帧，序号取上界值，上界加1；每**接收到一个正确响应帧**，下界加1；

  - 接收方

    - 接收端有一个接收窗口，大小固定，但不一定与发送窗口相同。接收窗口的上界表示**允许接收**的序号最大的帧，下界表示**希望接收**的帧；
    - 落在窗口外的帧均被丢弃。序号**等于下界**的帧被正确接收，**并产生一个响应帧**，下界加1。接收窗口大小不变。

    发送方的窗口：

![img](https://pic3.zhimg.com/80/v2-2c0a44a8f8b8300fe95649e896b298ca_1440w.jpg)

接收方的窗口：

![img](https://pic3.zhimg.com/80/v2-2bbd4fba05fc50d80671254bf9e21fce_1440w.jpg)

**滑动窗口有以下特性：**

> 1. 发送窗口的移动受接收窗口的限制：只有接收窗口向前滑动时，发送窗口才有可能向前滑动 （即**只有接收端发送了确认帧，并且发送方接收到确认帧时，发送窗口才会滑动**）
> 2. 接收窗口为1时，可以保证帧的**有序**接收（停止-等待协议、后退N帧协议）

##### 3.4.1 一比特滑动窗口协议

- 窗口大小：N = 1，发送序号和接收序号的取值范围都是：0，1；
- 相当于停-等协议，如果发送方没有收到确认，就不能发送下一帧。只能一帧一帧的发，效率很低。

##### 3.4.2 多滑动窗口的后退N帧协议

发送窗口大小>1，接收窗口大小=1。

**累计确认：**若接收方对N号帧确认，即代表接收方已经接收到了N号帧及N号以前的所有帧。发送方如果收到了这样的确认信息，那么就可以一下子直接把发送窗口右移到N，表明N之前所有的帧全部都已收到。这就叫做累计确认。

![img](https://pic3.zhimg.com/80/v2-c3225c7566fd5758f9827e1646448cca_1440w.jpg)

**后退N帧：**主要发生在帧**丢失**等情况。比如发送方已经发送了5+N个帧，但是接收方没有收到第5个帧的数据，那么从第5个帧开始，**剩下的N个帧都要重新发送**。

![img](https://pic3.zhimg.com/80/v2-ec83257883ddb9174e4b5c1bfdb4ab7e_1440w.jpg)

![img](https://pic2.zhimg.com/80/v2-3bd818542cd87ca19b6712b22ae848ed_1440w.jpg)

如果1号帧接收方没有接收到，即便2、3号帧已经到达接收方，接收方也会将他们丢弃，因为接收方**只期待1号帧的到来（exceptedseqnum=1）**，而2、3号帧显然不是接收方正在expect的帧，所以都被丢弃了。

注意：发送方发送数据可以不按序发送，只要是在发送窗口的数据均可以发送（可以按1、0、3、2的顺序），但是接收方只能够按序接收数据。

完整的后退n帧重传协议：

![img](https://pic4.zhimg.com/80/v2-acef3919dcfae0e6df54d246665c2307_1440w.jpg)

#####  3.4.3 选择重传协议

上文所述的回退n帧重传协议的问题在于 -- 重传的时候会重传很多分组（比如序列号分组n丢失时，需要重传n以及n以后没有确认的分组）。这样就会导致网络中充斥着很多重传的分组。那么，能不能只重传出错的分组呢？
因此，一种改进的机制就是不使用累积确认，采用**单个确认**；同时我们也不丢弃乱序的分组，将其**缓存**起来。这时，发送方只需要重传那些没收到ACK的分组。现在对**每个分组设置单独的定时器**，当某个分组的定时器超时后对其进行重传。

发送方：

1.  从上层收到数据。当从上层收到数据后，检查发送方下一个可用于该分组的序号。如果序号位于**发送方的窗口内**，则将数据打包并发送。
2.  超时。 定时器再次被用来防止丢失分组。然而，**现在每一个分组必须由自己的逻辑定时器**，因为超时发送后**只能发送一个分组**。
3.  收到ACK。 如果收到ACK,若该分组序号在窗口内，则发送方将那个被确认的分组标记为**已接收**。如果该序号范围等于send_base（窗口左端）,则窗口左端向前移动到具有最小序号的未被确认的分组处。

在接收方，失序的分组将被缓存直到所有丢失的分组（即**序号更小**的分组）都被收到为止，这是才将一批分组按序交付给上层。



![img](https://upload-images.jianshu.io/upload_images/16047645-fc861d950fa01bf5?imageMogr2/auto-orient/strip|imageView2/2/w/698/format/webp)

