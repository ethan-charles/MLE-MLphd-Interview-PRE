![img](https://upload-images.jianshu.io/upload_images/21727303-e0117a889aa7d78d.png?imageMogr2/auto-orient/strip|imageView2/2/w/738/format/webp)

从IP层来说，通信的两端是**两台主机**。但是严格来讲，两台主机之间的通信就是**两台主机中的应用进程相互通信**。

从运输层的角度，通信的真正端点并不是主机而是主机中的进程。也就是说，**端到端的通信是应用进程之间的通信**。

![img](https://upload-images.jianshu.io/upload_images/21727303-444f2540bc64184f.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)

概括的来说，就是网络层根据IP地址只能找到对应的是哪台**主机**，而运输层能够找到该主机上的具体哪个**应用进程**进行通信。



**2.运输层的作用**

- 在一台主机中经常有**多个应用进程**同时分别和另一台主机中的**多个应用进程**通信，这就表明运输层有一个很重要的功能——**复用**和**分用**。
- 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即**面向连接的TCP**和**无连接的UDP**。

![img](https://upload-images.jianshu.io/upload_images/21727303-988817517edabfdf.png?imageMogr2/auto-orient/strip|imageView2/2/w/729/format/webp)

TCP需要通信双方在传送数据之前要建立连接、数据传送过程中要维持连接、传送完毕后要释放连接。

TCP传送的协议数据单元叫做TCP报文段。

TCP协议要提供可靠的、面向连接的运输服务，就要实现流量控制、拥塞控制、确认、重传、连接管理以及计时器管理等多项功能，因此不可避免地会增加许多开销，这就使得TCP报文段的首部会比较复杂。复杂，需要占用。较多的处理器资源。TCP协议只能实现一对一，通信部提供广播或多播的服务



![img](https://upload-images.jianshu.io/upload_images/21727303-74169e97d9580ecb.png?imageMogr2/auto-orient/strip|imageView2/2/w/763/format/webp)



### 复用和分用

**3.基于端口的分用和复用功能**



![img](https:////upload-images.jianshu.io/upload_images/21727303-8b40ac44da6ad29c.png?imageMogr2/auto-orient/strip|imageView2/2/w/803/format/webp)

基于端口的分用和复用功能



> **复用**是在**发送端**实现的，把**多个应用进程的任务**放在同一条信道上传输；**分用**是在**接收端**实现的。为了区分不同进程，还引入了**端口号**，在复用和分用时都会用到，保证不会出现发送端的A进程的数据发送给接收端的B进程。





#### 3.运输层的端口

- 运行在计算机中的进程使用**进程标识符**来标志的。

**2.TCP/IP运输层端口**

- 端口用一个**16位**端口号进行标志。
- 端口号具有**本地意义**，即端口号只是为了标志**本计算机应用层中的各个进程**。在互联网中，**不同计算机的相同端口号是没有联系的**。由此可见，两个计算机中的进程要相互通信，不仅必须知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)。

**3.两大类端口**:client-server

- (1)**服务器**使用的端口号
   **熟知端口**：`1-1023`
   **登记端口号**：`1024-49151`，为没有熟知端口号的应用程序使用，使用这个范围内的端口号必须在IAN登记防止重复。
- (2).**客户端**使用的端口号
   **又称为短暂端口**，数值为`49152-65535`，留给客户进程选择暂时使用。

**常用的熟知端口**：
 



![img](https:////upload-images.jianshu.io/upload_images/21727303-4fc081423fb0bbad.png?imageMogr2/auto-orient/strip|imageView2/2/w/779/format/webp)







## 2.用户数据报协议UDP

#### 1.UDP概述

UDP只在IP数据报服务上增加了很少一点功能：**复用和分用**，**差错检测(对数据部分)**。
 **1.UDP的主要特点**

![img](https:////upload-images.jianshu.io/upload_images/21727303-3cab50a8b44cde29.png?imageMogr2/auto-orient/strip|imageView2/2/w/727/format/webp)

UDP的主要特点



![img](https:////upload-images.jianshu.io/upload_images/21727303-590da9e9b4905fcb.png?imageMogr2/auto-orient/strip|imageView2/2/w/727/format/webp)



2.面向报文的UDP

-  **发送方UDP**对应用程序交下来的报文，在添加首部后就向下交付IP层，UDP对应用层交下来的报文，**既不合并，也不拆分**，而是仅仅**添加一个UDP首部**，保留这些报文的边界。应用层交给UDP多长的报文，UDP就照常发送，即一次发送一个报文。
-  **接收方UDP**对IP层交上来的UDP用户数据，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。另外，应用程序必须选择合适大小的报文。报文太长的话，IP层在传输时可能要进行分片，这会降低IP层的效率；报文太短，IP层首部的相对长度太大，也会降低IP层的效率。

#### 2.UDP的首部格式



![img](https:////upload-images.jianshu.io/upload_images/21727303-87b692a3a20c21ba.png?imageMogr2/auto-orient/strip|imageView2/2/w/795/format/webp)

> **源端口**和**目的端口**字段就是用来**复用和分用**的；长度字段指的是整个UDP用户数据报的长度；检验和字段是用来对数据部分进行**差错检测**的。伪首部仅仅是用来**计算检验和**的，实际上并不会发送给接收方。

## 3.传输控制协议TCP概述

#### 1.TCP最主要的特点

- TCP是**面向连接**的运输层协议。
- 每一条TCP连接只能有两个端点，每一条TCP的连接只能是**点对点的(一对一)**。
- TCP提供**可靠交付**的服务：无差错、不丢失、不重复、按序到达
- TCP提供**全双工通信**。任何时间都能发送数据，有发送缓存、接收缓存
-  **面向字节流**。
   它的含义是虽然应用程序和TCP的交互是一个数据块，但是TCP把应用程序交下来的数据看成仅仅是一连串的无结构的数字流。

TCP面向字节流（流入/流出进程的字节序列）的概念：

- TCP**不保证**接收方应用程序所收到的数据块和发送方应用程序所发出的**数据块具有对应大小的关系(可能被拆分或合并)**。
- 但接收方应用程序收到的字节流必须和发送方应用程序发出的**字节流完全一样**。



![img](https:////upload-images.jianshu.io/upload_images/21727303-0a6dc3eaab1a3760.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

TCP面向流

> 注意，当发送端发送数据到**发送缓存**中后，并不能一口气将它们全部发送出去（而应该根据流量控制，决定报文段的大小）；同样的，接收方在接收数据时也是将数据先放入**接收缓存**，如果**接收缓存是满**的，那么此时再发送进来的数据就**会丢失**。假设接收缓存中还能再接收2个字节的数据，那么如果发送缓存中的数据大于2个字节，不能全部发送，只能**拆分**发送。当发送缓存中的数据小于接收缓存中的最大数据量时，发送缓存中的数据就会**合并**一起发送出去。其余的数据在发送缓存中等待下一次发送。等到接收缓存中的数据被读取完了之后，发送缓存中的数据才发送。



![img](https:////upload-images.jianshu.io/upload_images/21727303-d4753fab3ff211df.png?imageMogr2/auto-orient/strip|imageView2/2/w/759/format/webp)

#### 2.TCP的连接

- TCP把连接作为**最基本的抽象**。
- 每一条TCP连接有**两个端点**。
- TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。而是套接字。所谓**套接字**就是**端口号拼接到IP地址后面**就构成了套接字。



![img](https:////upload-images.jianshu.io/upload_images/21727303-79865b83a6edcc50.png?imageMogr2/auto-orient/strip|imageView2/2/w/792/format/webp)

套接字

> 注意，**同一个IP地址可以有多个不同的TCP连接(多个不同的端口)，同一个端口也可以出现在多个不同的TCP连接中**。



## 5.TCP报文段的首部格式



![img](https:////upload-images.jianshu.io/upload_images/21727303-e0035a8894e43fd4.png?imageMogr2/auto-orient/strip|imageView2/2/w/756/format/webp)

字节流分成若干个报文段传输



![img](https:////upload-images.jianshu.io/upload_images/21727303-62400870a88cf1be.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)

TCP报文段的首部格式

> **源端口和目的端口字段**：各16位，源端口用来实现**复用**，目的端口用来实现**分用**；
>
> **序号字段**：4个字节，就是之前说的编号机制，TCP连接中传送的数据流中的每一个字节都编上一个序号，首部中的序号字段指的就是第一个字节的序号；（连续的两个报文段序号字段一般不连续）
>
> **确认号字段**：4个字节，是期望收到的对方的**下一个报文段的数据**的第一个字节的序号；
>
> **数据偏移字段**：即**首部长度**，4位，指的是数据部分起始处距离整个报文的起始处间的距离（因为首部长度是可变的），计算单位是4个字节；
>
> **保留字段**：6位，保留为今后使用目前置为0；
>  **紧急URG**：当URG=1时，表明报文段中有紧急数据，这些数据需要优先传送，当然还需要知道紧急数据的位置的话光靠这个字段是不够的，还需要紧急指针。
>  **确认ACK**：当ACK=1时，确认号字段(ack)才有效；ACK=0时，确认号无效。
>  **推送PSH**：当接收到TCP=1的报文段就应该尽快交付不必要等缓存填满再交付。
>  **复位RST**：当RST=1时，表明TCP连接中出现严重差错，必须**释放连接**再重新连接。
>  **同步SYN**：当SYN=1时，表明这是一个**连接请求**或者**连接接收**报文。
>  **终止FIN**：用来**释放**一个连接。FIN=1表示此报文段发送端的数据已经发送完毕，**要求释放连接**。
>  **窗口字段**：2字节，用来让对方设置发送窗口的依据，也就是接收窗口的大小；
>
> **检验和字段**：2字节，检验的部分包括首部和数据部分；
>
> **紧急指针字段**：16位，指出紧急数据共多少字节，放在本报文段数据的最前面；**选项字段**：长度可变，MSS是TCP报文段中的**数据字段的最大长度**；





TCP三次握手如图：

![这里写图片描述](https://img-blog.csdn.net/20180808105159546?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bjIwMTY0MjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2.1 第一次握手
客户端给服务器发送一个SYN段(在 TCP 标头中 SYN 位字段为 1 的 TCP/IP 数据包), 该段中也包含客户端的**初始序列号**(Sequence number = J)。

SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接

2.2 第二次握手
服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)， 该段中包含服务器的**初始序列号**(Sequence number = K)；同时使 Acknowledgment number = **J + 1**来表示确认已收到客户端的 SYN段(Sequence number = J)。

ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包

2.3 第三次握手
客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 **1** 的 TCP/IP 数据包), 该段中使 Acknowledgment number = K + 1来表示确认已收到服务器的 SYN段(Sequence number = K)。





![img](https://pic2.zhimg.com/80/v2-977ba5740b90508cfcdf29a4ae523fe4_1440w.png)

中断连接端可以是客户端，也可以是服务器端。

第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入**FIN_WAIT_2** 状态，继续等待服务器端的FIN报文。

第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我**这边数据发完了，准备好关闭连接了**。服务器端进入LAST_ACK状态。

第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

