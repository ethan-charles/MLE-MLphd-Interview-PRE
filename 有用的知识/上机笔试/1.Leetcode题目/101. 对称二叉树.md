#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

难度简单1912

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

```
输入：root = [1,2,2,3,4,4,3]
输出：true

```

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

解1. 递归

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def identical(root1,root2): ###重点在于想到传入两个root
            if (not root1 and root2) or (root1 and not root2): 
                return False
            if not root1 and not root2: return True
            if root1.val != root2.val: return False
            return identical(root1.left,root2.right) and identical(root1.right,root2.left)
        return identical(root,root) 
```

解2. 迭代

递归的方式很好写，那么如果用迭代法呢？其实，迭代法就是需要稍微修改**层次遍历**的代码。每次，我们从队列中取出头部的**两个节点**，判断两者是否相等。然后，把左右节点的孩子反向push进栈。具体的做法如下：

![1.gif](https://pic.leetcode-cn.com/45a663b08efaa14193d63ef63ae3d1d130807467d13707f584906ad3af4adc36-1.gif)

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        queue = [root,root]
        while len(queue) >= 2:
            front1 = queue[0]
            front2 = queue[1]
            if front1.val != front2.val:
                return False
            if (front1.right and not front2.left) or (not front1.right and front2.left) or (front1.left and not front2.right) or (not front1.left and front2.right): return False
            if front1.right:
                queue.append(front1.right)
                queue.append(front2.left)
            if front1.left:
                queue.append(front1.left)
                queue.append(front2.right)

            queue = queue[2:]
        return True
```

