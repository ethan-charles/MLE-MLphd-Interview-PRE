[TOC]



# 专题 - 最长递增子序列 [上升]

#### 最长递增子序列长度（LIS问题）

dp，每个位置记录以它为结尾的最长递增子序列长度。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1]*len(nums) ##初始化为1
        for i in range(1,len(nums)):
            for j in range(i): ##遍历之前的位置
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

【引申】如果让**输出**最长递增子序列呢？

其实也很简单，就是求完dp数组之后找到最大的那个位置，然后往回推。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1]*len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i],dp[j]+1)
        mmax = 0
        max_idx = -1 ##找到dp数组最大的那个位置
        for i in range(len(dp)):
            if dp[i] > mmax:
                mmax = dp[i]; max_idx = i
        ptr = max_idx
        ans = [nums[ptr]]
        while len(ans) < mmax:
            for i in range(ptr-1,-1,-1):
                if dp[i] == dp[ptr] - 1 and nums[i] < nums[ptr]:
                    ans.append(nums[i])
                    ptr = i
                    break
        print(ans[::-1]) ##这就是答案了！
        return max(dp)
```



**O(nlogn)解法：贪心+二分查找**

考虑一个简单的**贪心**，如果我们要使上升子序列尽可能的长，则我们需要**让序列上升得尽可能慢**，因此我们希望每次在上升子序列**最后加上的那个数尽可能的小**。

基于上面的贪心思路，我们维护一个数组 `d[i]` ，表示长度为 `i `的最长上升子序列的末尾元素的最小值。我们可以注意到 `d[i]` 是关于`i` 单调递增的。

我们依次遍历数组 `nums` 中的每个元素，并更新数组 d：

① 如果 `nums[i]>d[-1]` 则把`nums[i]`加入到d中；

② 否则，在d中找满足 d[i−1]<nums[j]<d[i] 的下标 i，并更新d[i]=nums[j]。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        d = []
        for n in nums:
            if not d or n > d[-1]:
                d.append(n)
            else:
                l, r = 0, len(d) - 1
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        r = mid - 1
                    else:
                        l = mid + 1
                d[l] = n
        return len(d)
```



#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

难度中等587

给定一个未排序的整数数组 `nums` ， *返回最长递增子序列的个数* 。

**注意** 这个数列必须是 **严格** 递增的。

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

**题解：**

先把最长递增子序列的默写一遍qwq, 然后再此基础上进行修改。

例如下面的例子中，要求7之前的最长递增子序列个数。可以看到，7之前有两个位置都符合”最长“递增子序列的标准，那么就应该把这两个结尾位置对应的个数都加起来。

![img](https://pica.zhimg.com/80/v2-16006a3e4d2d695c5c00f58963ce5e43_1440w.png)

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        dp = [1] *len(nums)
        dp[0] = (1,1) ##长度, 个数
        for i in range(1,len(nums)):
            mmax = 0 ##前面的最长子序列长度
            for j in range(i):
                if nums[j] < nums[i]:
                    mmax = max(dp[j][0],mmax)
            cnt = 0
            for j in range(i):
                if nums[j] < nums[i] and dp[j][0] == mmax: ##把所有最长子序列的个数都加起来
                    cnt += dp[j][1]
            dp[i] = (mmax+1,max(cnt,1))  ##cnt至少为1
        mmax = 0
        cnt = 0 ##把所有最长子序列的个数都加起来
        for i in range(len(nums)):
                mmax = max(mmax,dp[i][0])
        for i in range(len(nums)):
            if dp[i][0] == mmax:
                cnt += dp[i][1]
        return cnt
```







#### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

难度中等445

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

题解：

使用类似LIS的dp方法，每个位置记录以它为结尾的上升子序列，在dp的时候每个位置都会考察前面比它小的那些位置的上升序列

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        dp = [[] for _ in range(len(nums))]
        ans_list = []
        dp[0] = [[nums[0]]]
        for i in range(1,len(nums)):
            ans = [[nums[i]]]
            for j in range(i):
                if nums[j] <= nums[i]:
                    prev_ans = dp[j]
                    for item in prev_ans:
                        ans.append(item+[nums[i]])
            dp[i] = ans
            for item in ans:
                if len(item) >= 2 and item not in ans_list:
                    ans_list.append(item)
        return ans_list
```



#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度中等672

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```



题解：两个dp数组，一个记录最后一个上升的最长子序列，另一个记录最后一位下降的最长子序列

```
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        dp_up = [1]*len(nums) ##最后一位在上升
        dp_down = [1]*len(nums) ##最后一位在下降
        mmax = 1
        for i in range(1,len(nums)):
            max_up = 0
            max_down = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    max_up = max(max_up,dp_down[j])
                if nums[j] > nums[i]:
                    max_down = max(max_down,dp_up[j])
            dp_up[i] = max_up + 1
            dp_down[i] = max_down + 1
            mmax = max(dp_up[i],dp_down[i],mmax)
        return mmax
```

