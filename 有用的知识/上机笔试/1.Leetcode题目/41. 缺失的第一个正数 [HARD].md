# 41. 缺失的第一个正数 [HARD]

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

```python
示例 1：
输入：nums = [1,2,0]
输出：3

示例 2：
输入：nums = [3,4,-1,1]
输出：2

示例 3：
输入：nums = [7,8,9,11,12]
输出：1
```



#### 方法1：哈希表 （空间复杂度不合要求）

首先想清楚一件事，长度为N的数组中没有出现的**最小正整数只可能是[1,N+1]**. 这是因为如果N个最小的正整数1,2,...N都出现的话，那么最小的未出现正整数就是N+1了。

所以，可以把所有出现过的数字存进哈希表，然后去遍历[1,N+1], 直到找到第一个未出现于哈希表中的数。

#### 方法2：原地哈希

既然哈希表的空间复杂度不合要求，那么，可不可以直接利用现在的数组，将其改造成一个哈希表呢？

由于我们只在意[1,N]中的数，因此我们可以先对数组进行遍历，把不在[1，N]范围内的数修改成一个不可能的数IMPOSSIBLE = 100000000, 防止它们干扰我们。这一步属于预处理。

然后，就要进行原地哈希了。对于那些不是IMPOSSIBLE的数，我们去把其对应位置上的值打一个“标记”，这个标记其实就是把原来的值变成负数，这是因为改变之后我们还需要知道原来的值是什么，不能覆盖掉了。这样，所有出现过的数我们已经打好了标记，下一步就是遍历整个数组，找到第一个是正数的（索引为i），然后返回i+1即可。

![img](https://pic3.zhimg.com/80/v2-0afe54f338d50ed5c645f1ed1add249e_1440w.png)

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        ##### 答案一定在1~n+1之间
        n = len(nums)
        IMP = 1000000000000 ###这个数要写的大一些！！！
        for i in range(len(nums)):
            if nums[i] < 1 or nums[i] > n: ###0也是IMP
                nums[i] = IMP
        nums = [0]+nums
        for i in range(1,len(nums)):
            if abs(nums[i]) != IMP: ##只对非IMP做处理
                nums[abs(nums[i])] = -abs(nums[abs(nums[i])]) ##相反数
        for i in range(1,len(nums)):
            if nums[i] > 0:
                return i
        return len(nums)
```

