# LFU缓存

#### [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

请你为 [最不经常使用（LFU）](https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95)缓存算法设计并实现数据结构。

实现 `LFUCache` 类：

- `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象
- `int get(int key)` - 如果键 `key` 存在于缓存中，则**获取键的值**，否则返回 `-1` 。-> 需要维护一个由key到val的映射。
- `void put(int key, int value)` - 如果键 `key` 已存在，则**变更其值**；如果键不存在，请插入键值对->（上面所说的key到val映射就可以做到了；)当缓存达到其容量 `capacity` 时，则应该在插入新项之前，**移除**最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最近最久未使用** 的键。

为了确定最不常使用的键，可以为缓存中的每个键维护一个 **使用计数器** 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 `1` (由于 put 操作)。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。





#### 题解：

本题不可能要求现场写出代码，所以只要了解思路即可。

一定先从最简单的开始，根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：

1、调用 get(key) 方法时，要**返回**该 key 对应的 val。

2、只要用 get 或者 put 方法访问一次某个 key，该 key 的 freq 就要加一。

3、如果在容量满了的时候进行插入，则需要将 freq **最小的 key** 删除；如果最小的 freq 对应多个 key，则删除其中**最旧**的那一个。



好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：

1、使用一个 HashMap 存储 key 到 val 的映射，就可以快速计算 get(key)。
2、使用一个 HashMap 存储 key 到 freq 的映射，就可以快速操作 key 对应的 freq。
3、这个需求应该是 LFU 算法的核心，所以我们分开说。

3.1、首先，肯定是需要 **freq 到 key 的映射**，用来找到 freq 最小的 key。

3.2、将 freq 最小的 key 删除，那你就得快速得到当前所有 key 最小的 freq 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，**那就用一个变量 minFreq 来记录当前最小的 freq 吧**。

3.3、可能有多个 key 拥有相同的 freq，所以 **freq 对 key 是一对多的关系**，即**一个 freq 对应一个 key 的列表**。

3.4、希望 freq 对应的 key 的列表**是存在时序的**，便于快速查找并删除最旧的 key。

3.5、希望能够快速删除 key 列表中的任何一个 key，因为如果频次为 freq 的某个 key 被访问，那么它的频次就会变成 **freq+1**，就应该从 freq 对应的 key 列表中**删除**，**加到 freq+1 对应的 key 的列表中**。



